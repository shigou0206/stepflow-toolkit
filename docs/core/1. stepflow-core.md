# stepflow-core - æ ¸å¿ƒåº“

## ğŸ“‹ æ¦‚è¿°

`stepflow-core` æ˜¯æ•´ä¸ª Stepflow Tool System çš„æ ¸å¿ƒåº“ï¼Œå®šä¹‰äº†æ‰€æœ‰å…¶ä»–åŒ…å¿…é¡»éµå¾ªçš„åŸºç¡€æ•°æ®ç»“æ„å’Œæ¥å£ã€‚

**èŒè´£**: 
- å®šä¹‰æ ¸å¿ƒæ•°æ®ç»“æ„å’Œç±»å‹
- æä¾›ç»Ÿä¸€çš„æ¥å£æŠ½è±¡
- å®šä¹‰é”™è¯¯ç±»å‹å’Œå¸¸é‡
- ç¡®ä¿ç±»å‹å®‰å…¨å’Œä¸€è‡´æ€§

---

## ğŸ—ï¸ åŒ…ç»“æ„

```
stepflow-core/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs              # åº“å…¥å£
â”‚   â”œâ”€â”€ models.rs           # æ ¸å¿ƒæ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ traits.rs           # æ ¸å¿ƒ trait å®šä¹‰
â”‚   â”œâ”€â”€ errors.rs           # é”™è¯¯ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ types.rs            # ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ constants.rs        # å¸¸é‡å®šä¹‰
â”‚   â””â”€â”€ utils.rs            # å·¥å…·å‡½æ•°
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ models_test.rs      # æ•°æ®æ¨¡å‹æµ‹è¯•
â”‚   â”œâ”€â”€ traits_test.rs      # trait æµ‹è¯•
â”‚   â””â”€â”€ errors_test.rs      # é”™è¯¯ç±»å‹æµ‹è¯•
â””â”€â”€ Cargo.toml
```

---

## ğŸ“¦ ä¾èµ–é…ç½®

```toml
[package]
name = "stepflow-core"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
thiserror = "1.0"
async-trait = "0.1"
validator = { version = "0.16", features = ["derive"] }

[dev-dependencies]
tokio = { version = "1.0", features = ["full"] }
```

---

## ğŸ¯ æ ¸å¿ƒæ•°æ®ç»“æ„

### 1. ToolSpec - å·¥å…·è§„èŒƒ

```rust
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct ToolSpec {
    #[validate(length(min = 1, max = 100))]
    pub id: ToolId,
    
    #[validate(length(min = 1, max = 200))]
    pub name: String,
    
    #[validate(length(min = 1, max = 1000))]
    pub description: String,
    
    pub tool_type: ToolType,
    
    #[validate]
    pub input_schema: serde_json::Value,
    
    #[validate]
    pub output_schema: serde_json::Value,
    
    pub config: serde_json::Value,
    
    #[validate(length(max = 20))]
    pub tags: Vec<String>,
    
    pub category: Option<String>,
    
    #[validate(regex = "^(v\\d+\\.\\d+\\.\\d+|latest)$")]
    pub version: String,
    
    pub tenant_id: TenantId,
    
    pub registered_at: DateTime<Utc>,
    
    #[validate]
    pub execution_config: ExecutionConfig,
}

impl ToolSpec {
    /// éªŒè¯å·¥å…·è§„èŒƒ
    pub fn validate(&self) -> Result<(), ValidationError> {
        // éªŒè¯ ID æ ¼å¼
        if !self.id.is_valid() {
            return Err(ValidationError::InvalidToolId);
        }
        
        // éªŒè¯ Schema æ ¼å¼
        self.validate_schemas()?;
        
        // éªŒè¯é…ç½®
        self.validate_config()?;
        
        Ok(())
    }
    
    /// ç”Ÿæˆå·¥å…· ID
    pub fn generate_id(namespace: &str, name: &str, version: &str) -> ToolId {
        ToolId::new(&format!("tool:{}:{}/{}", namespace, name, version))
    }
}
```

### 2. ToolId - å·¥å…·æ ‡è¯†ç¬¦

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct ToolId(String);

impl ToolId {
    pub fn new(id: &str) -> Self {
        Self(id.to_string())
    }
    
    pub fn as_str(&self) -> &str {
        &self.0
    }
    
    pub fn is_valid(&self) -> bool {
        // éªŒè¯æ ¼å¼: tool:<namespace>/<name>@<version>
        let re = regex::Regex::new(r"^tool:[^/]+/[^@]+@[^@]+$").unwrap();
        re.is_match(&self.0)
    }
    
    pub fn parse(&self) -> Result<(String, String, String), ToolIdError> {
        // è§£æ namespace, name, version
        let parts: Vec<&str> = self.0.split('/').collect();
        if parts.len() != 2 {
            return Err(ToolIdError::InvalidFormat);
        }
        
        let namespace = parts[0].strip_prefix("tool:").ok_or(ToolIdError::InvalidFormat)?;
        let name_version: Vec<&str> = parts[1].split('@').collect();
        if name_version.len() != 2 {
            return Err(ToolIdError::InvalidFormat);
        }
        
        Ok((
            namespace.to_string(),
            name_version[0].to_string(),
            name_version[1].to_string(),
        ))
    }
}
```

### 3. ToolType - å·¥å…·ç±»å‹

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum ToolType {
    OpenApiTool,
    AsyncApiTool,
    PythonScript,
    ShellCommand,
    AITool,
    SystemTool,
    HttpRest,
    WebhookReceiver,
    StepflowSubflow,
    PromptTemplate,
    Custom(String),
}

impl ToolType {
    pub fn as_str(&self) -> &str {
        match self {
            ToolType::OpenApiTool => "OpenApiTool",
            ToolType::AsyncApiTool => "AsyncApiTool",
            ToolType::PythonScript => "PythonScript",
            ToolType::ShellCommand => "ShellCommand",
            ToolType::AITool => "AITool",
            ToolType::SystemTool => "SystemTool",
            ToolType::HttpRest => "HttpRest",
            ToolType::WebhookReceiver => "WebhookReceiver",
            ToolType::StepflowSubflow => "StepflowSubflow",
            ToolType::PromptTemplate => "PromptTemplate",
            ToolType::Custom(s) => s,
        }
    }
    
    pub fn from_str(s: &str) -> Result<Self, ToolTypeError> {
        match s {
            "OpenApiTool" => Ok(ToolType::OpenApiTool),
            "AsyncApiTool" => Ok(ToolType::AsyncApiTool),
            "PythonScript" => Ok(ToolType::PythonScript),
            "ShellCommand" => Ok(ToolType::ShellCommand),
            "AITool" => Ok(ToolType::AITool),
            "SystemTool" => Ok(ToolType::SystemTool),
            "HttpRest" => Ok(ToolType::HttpRest),
            "WebhookReceiver" => Ok(ToolType::WebhookReceiver),
            "StepflowSubflow" => Ok(ToolType::StepflowSubflow),
            "PromptTemplate" => Ok(ToolType::PromptTemplate),
            _ => Ok(ToolType::Custom(s.to_string())),
        }
    }
}
```

### 4. ExecutionConfig - æ‰§è¡Œé…ç½®

```rust
#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct ExecutionConfig {
    #[validate(range(min = 1, max = 3600))]
    pub timeout: Duration,
    
    #[validate(range(min = 1, max = 1024))]
    pub memory_limit: Option<u64>,
    
    #[validate(range(min = 0.1, max = 100.0))]
    pub cpu_limit: Option<f64>,
    
    pub sandbox_level: SandboxLevel,
    
    #[validate]
    pub retry_config: RetryConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SandboxLevel {
    None,
    Basic,
    Strict,
    Process,
}

#[derive(Debug, Clone, Serialize, Deserialize, Validate)]
pub struct RetryConfig {
    #[validate(range(min = 0, max = 10))]
    pub max_retries: u32,
    
    #[validate(range(min = 100, max = 30000))]
    pub retry_delay: Duration,
    
    pub backoff_strategy: BackoffStrategy,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BackoffStrategy {
    Fixed,
    Exponential,
    Linear,
}
```

---

## ğŸ”§ æ ¸å¿ƒ Trait å®šä¹‰

### 1. ToolHandler - å·¥å…·å¤„ç†å™¨æ¥å£

```rust
#[async_trait]
pub trait ToolHandler: Send + Sync {
    /// éªŒè¯å·¥å…·é…ç½®
    async fn validate(&self, config: &serde_json::Value) -> Result<(), ToolError>;
    
    /// æ‰§è¡Œå·¥å…·
    async fn execute(&self, input: &serde_json::Value) -> Result<serde_json::Value, ToolError>;
    
    /// æ¸…ç†èµ„æº
    async fn cleanup(&self) -> Result<(), ToolError>;
    
    /// è·å–å·¥å…·ç±»å‹
    fn tool_type(&self) -> ToolType;
    
    /// è·å–å·¥å…·æè¿°
    fn description(&self) -> &str;
}

/// å·¥å…·å¤„ç†å™¨å·¥å‚
pub trait ToolHandlerFactory: Send + Sync {
    fn create_handler(&self, config: &serde_json::Value) -> Result<Box<dyn ToolHandler>, ToolError>;
    fn supported_types(&self) -> Vec<ToolType>;
}
```

### 2. ToolRegistry - å·¥å…·æ³¨å†Œæ¥å£

```rust
#[async_trait]
pub trait ToolRegistry: Send + Sync {
    /// æ³¨å†Œå·¥å…·
    async fn register_tool(&self, tool: ToolSpec) -> Result<ToolId, RegistryError>;
    
    /// è·å–å·¥å…·
    async fn get_tool(&self, id: &ToolId) -> Result<ToolSpec, RegistryError>;
    
    /// åˆ—å‡ºå·¥å…·
    async fn list_tools(&self, filter: ToolFilter) -> Result<Vec<ToolSpec>, RegistryError>;
    
    /// æ›´æ–°å·¥å…·
    async fn update_tool(&self, id: &ToolId, tool: ToolSpec) -> Result<(), RegistryError>;
    
    /// åˆ é™¤å·¥å…·
    async fn delete_tool(&self, id: &ToolId) -> Result<(), RegistryError>;
    
    /// æœç´¢å·¥å…·
    async fn search_tools(&self, query: &str) -> Result<Vec<ToolSpec>, RegistryError>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolFilter {
    pub tool_type: Option<ToolType>,
    pub tenant_id: Option<TenantId>,
    pub tags: Option<Vec<String>>,
    pub category: Option<String>,
    pub limit: Option<usize>,
    pub offset: Option<usize>,
}
```

### 3. ToolExecutor - å·¥å…·æ‰§è¡Œæ¥å£

```rust
#[async_trait]
pub trait ToolExecutor: Send + Sync {
    /// æ‰§è¡Œå·¥å…·
    async fn execute_tool(
        &self,
        tool_id: &ToolId,
        input: &serde_json::Value,
    ) -> Result<serde_json::Value, ExecutionError>;
    
    /// æ‰¹é‡æ‰§è¡Œå·¥å…·
    async fn execute_tools(
        &self,
        executions: Vec<ToolExecution>,
    ) -> Result<Vec<ExecutionResult>, ExecutionError>;
    
    /// è·å–æ‰§è¡ŒçŠ¶æ€
    async fn get_execution_status(&self, execution_id: &ExecutionId) -> Result<ExecutionStatus, ExecutionError>;
    
    /// å–æ¶ˆæ‰§è¡Œ
    async fn cancel_execution(&self, execution_id: &ExecutionId) -> Result<(), ExecutionError>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolExecution {
    pub tool_id: ToolId,
    pub input: serde_json::Value,
    pub timeout: Option<Duration>,
    pub priority: ExecutionPriority,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionResult {
    pub execution_id: ExecutionId,
    pub tool_id: ToolId,
    pub output: serde_json::Value,
    pub duration: Duration,
    pub status: ExecutionStatus,
    pub error: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutionStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
    Timeout,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutionPriority {
    Low = 1,
    Normal = 5,
    High = 10,
    Critical = 20,
}
```

---

## ğŸš¨ é”™è¯¯ç±»å‹å®šä¹‰

### 1. æ ¸å¿ƒé”™è¯¯ç±»å‹

```rust
#[derive(Debug, thiserror::Error)]
pub enum ToolError {
    #[error("Invalid tool specification: {0}")]
    InvalidSpec(String),
    
    #[error("Tool execution failed: {0}")]
    ExecutionFailed(String),
    
    #[error("Tool validation failed: {0}")]
    ValidationFailed(String),
    
    #[error("Tool not found: {0}")]
    ToolNotFound(ToolId),
    
    #[error("Permission denied: {0}")]
    PermissionDenied(String),
    
    #[error("Resource limit exceeded: {0}")]
    ResourceLimitExceeded(String),
    
    #[error("Timeout: {0}")]
    Timeout(String),
    
    #[error("Internal error: {0}")]
    Internal(String),
}

#[derive(Debug, thiserror::Error)]
pub enum RegistryError {
    #[error("Tool already exists: {0}")]
    ToolAlreadyExists(ToolId),
    
    #[error("Tool not found: {0}")]
    ToolNotFound(ToolId),
    
    #[error("Invalid tool specification: {0}")]
    InvalidSpec(String),
    
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Permission denied: {0}")]
    PermissionDenied(String),
}

#[derive(Debug, thiserror::Error)]
pub enum ExecutionError {
    #[error("Tool not found: {0}")]
    ToolNotFound(ToolId),
    
    #[error("Execution failed: {0}")]
    ExecutionFailed(String),
    
    #[error("Timeout: {0}")]
    Timeout(String),
    
    #[error("Resource limit exceeded: {0}")]
    ResourceLimitExceeded(String),
    
    #[error("Invalid input: {0}")]
    InvalidInput(String),
    
    #[error("Sandbox error: {0}")]
    SandboxError(String),
}
```

### 2. éªŒè¯é”™è¯¯ç±»å‹

```rust
#[derive(Debug, thiserror::Error)]
pub enum ValidationError {
    #[error("Invalid tool ID format")]
    InvalidToolId,
    
    #[error("Invalid schema: {0}")]
    InvalidSchema(String),
    
    #[error("Invalid configuration: {0}")]
    InvalidConfig(String),
    
    #[error("Missing required field: {0}")]
    MissingField(String),
    
    #[error("Field validation failed: {field} - {reason}")]
    FieldValidation { field: String, reason: String },
}

#[derive(Debug, thiserror::Error)]
pub enum ToolIdError {
    #[error("Invalid tool ID format")]
    InvalidFormat,
    
    #[error("Invalid namespace: {0}")]
    InvalidNamespace(String),
    
    #[error("Invalid name: {0}")]
    InvalidName(String),
    
    #[error("Invalid version: {0}")]
    InvalidVersion(String),
}

#[derive(Debug, thiserror::Error)]
pub enum ToolTypeError {
    #[error("Unknown tool type: {0}")]
    UnknownType(String),
    
    #[error("Unsupported tool type: {0}")]
    UnsupportedType(String),
}
```

---

## ğŸ“Š ç±»å‹å®šä¹‰

### 1. åŸºç¡€ç±»å‹

```rust
pub type TenantId = String;
pub type ExecutionId = Uuid;
pub type ToolId = String;

/// å·¥å…·æ‰§è¡Œä¸Šä¸‹æ–‡
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionContext {
    pub execution_id: ExecutionId,
    pub tenant_id: TenantId,
    pub user_id: Option<String>,
    pub request_id: Option<String>,
    pub metadata: HashMap<String, serde_json::Value>,
}

/// å·¥å…·æ‰§è¡Œè¯·æ±‚
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionRequest {
    pub tool_id: ToolId,
    pub input: serde_json::Value,
    pub context: ExecutionContext,
    pub timeout: Option<Duration>,
    pub priority: ExecutionPriority,
}

/// å·¥å…·æ‰§è¡Œå“åº”
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionResponse {
    pub execution_id: ExecutionId,
    pub output: serde_json::Value,
    pub duration: Duration,
    pub status: ExecutionStatus,
    pub error: Option<String>,
    pub metadata: HashMap<String, serde_json::Value>,
}
```

### 2. å¸¸é‡å®šä¹‰

```rust
pub const MAX_TOOL_NAME_LENGTH: usize = 200;
pub const MAX_TOOL_DESCRIPTION_LENGTH: usize = 1000;
pub const MAX_TAGS_COUNT: usize = 20;
pub const MAX_TAG_LENGTH: usize = 50;
pub const DEFAULT_TIMEOUT: Duration = Duration::from_secs(30);
pub const MAX_TIMEOUT: Duration = Duration::from_secs(3600);
pub const DEFAULT_MEMORY_LIMIT: u64 = 512; // MB
pub const MAX_MEMORY_LIMIT: u64 = 1024; // MB
pub const DEFAULT_CPU_LIMIT: f64 = 1.0;
pub const MAX_CPU_LIMIT: f64 = 100.0;
```

---

## ğŸ§ª æµ‹è¯•æ ‡å‡†

### 1. å•å…ƒæµ‹è¯•è¦æ±‚

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_tool_spec_validation() {
        let valid_spec = ToolSpec {
            id: ToolId::new("tool:test:my_tool@v1"),
            name: "My Tool".to_string(),
            description: "A test tool".to_string(),
            tool_type: ToolType::PythonScript,
            input_schema: serde_json::json!({"type": "object"}),
            output_schema: serde_json::json!({"type": "object"}),
            config: serde_json::json!({}),
            tags: vec!["test".to_string()],
            category: Some("test".to_string()),
            version: "v1".to_string(),
            tenant_id: "tenant1".to_string(),
            registered_at: Utc::now(),
            execution_config: ExecutionConfig {
                timeout: Duration::from_secs(30),
                memory_limit: Some(512),
                cpu_limit: Some(1.0),
                sandbox_level: SandboxLevel::Basic,
                retry_config: RetryConfig {
                    max_retries: 3,
                    retry_delay: Duration::from_secs(1),
                    backoff_strategy: BackoffStrategy::Exponential,
                },
            },
        };
        
        assert!(valid_spec.validate().is_ok());
    }
    
    #[test]
    fn test_tool_id_parsing() {
        let tool_id = ToolId::new("tool:test:my_tool@v1");
        let (namespace, name, version) = tool_id.parse().unwrap();
        
        assert_eq!(namespace, "test");
        assert_eq!(name, "my_tool");
        assert_eq!(version, "v1");
    }
    
    #[test]
    fn test_tool_type_conversion() {
        assert_eq!(ToolType::PythonScript.as_str(), "PythonScript");
        assert_eq!(ToolType::from_str("PythonScript").unwrap(), ToolType::PythonScript);
    }
}
```

### 2. é›†æˆæµ‹è¯•è¦æ±‚

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_tool_registry_operations() {
        // æµ‹è¯•å·¥å…·æ³¨å†Œã€æŸ¥è¯¢ã€æ›´æ–°ã€åˆ é™¤çš„å®Œæ•´æµç¨‹
    }
    
    #[tokio::test]
    async fn test_tool_execution_flow() {
        // æµ‹è¯•å·¥å…·æ‰§è¡Œçš„å®Œæ•´æµç¨‹
    }
    
    #[tokio::test]
    async fn test_error_handling() {
        // æµ‹è¯•å„ç§é”™è¯¯æƒ…å†µçš„å¤„ç†
    }
}
```

### 3. æ€§èƒ½æµ‹è¯•è¦æ±‚

```rust
#[cfg(test)]
mod performance_tests {
    use super::*;
    
    #[test]
    fn test_tool_spec_serialization_performance() {
        // æµ‹è¯•åºåˆ—åŒ–/ååºåˆ—åŒ–æ€§èƒ½
    }
    
    #[test]
    fn test_tool_id_validation_performance() {
        // æµ‹è¯• ID éªŒè¯æ€§èƒ½
    }
}
```

### 4. æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

- **å•å…ƒæµ‹è¯•è¦†ç›–ç‡**: > 90%
- **é›†æˆæµ‹è¯•è¦†ç›–ç‡**: > 80%
- **é”™è¯¯è·¯å¾„æµ‹è¯•**: 100%
- **è¾¹ç•Œæ¡ä»¶æµ‹è¯•**: 100%

---

## ğŸ“‹ ä½¿ç”¨ç¤ºä¾‹

### 1. åˆ›å»ºå·¥å…·è§„èŒƒ

```rust
use stepflow_core::{ToolSpec, ToolType, ExecutionConfig, SandboxLevel, BackoffStrategy, RetryConfig};

let tool_spec = ToolSpec {
    id: ToolSpec::generate_id("python", "send_email", "v1"),
    name: "Send Email".to_string(),
    description: "Sends an email via SMTP".to_string(),
    tool_type: ToolType::PythonScript,
    input_schema: serde_json::json!({
        "type": "object",
        "properties": {
            "to": {"type": "string", "format": "email"},
            "subject": {"type": "string"},
            "body": {"type": "string"}
        },
        "required": ["to", "subject", "body"]
    }),
    output_schema: serde_json::json!({
        "type": "object",
        "properties": {
            "message_id": {"type": "string"},
            "status": {"type": "string"}
        }
    }),
    config: serde_json::json!({
        "smtp_server": "smtp.gmail.com",
        "smtp_port": 587
    }),
    tags: vec!["email".to_string(), "communication".to_string()],
    category: Some("communication".to_string()),
    version: "v1".to_string(),
    tenant_id: "tenant1".to_string(),
    registered_at: Utc::now(),
    execution_config: ExecutionConfig {
        timeout: Duration::from_secs(30),
        memory_limit: Some(256),
        cpu_limit: Some(0.5),
        sandbox_level: SandboxLevel::Strict,
        retry_config: RetryConfig {
            max_retries: 3,
            retry_delay: Duration::from_secs(1),
            backoff_strategy: BackoffStrategy::Exponential,
        },
    },
};

// éªŒè¯å·¥å…·è§„èŒƒ
tool_spec.validate()?;
```

### 2. å®ç°å·¥å…·å¤„ç†å™¨

```rust
use stepflow_core::{ToolHandler, ToolType, ToolError};
use async_trait::async_trait;

pub struct MyToolHandler;

#[async_trait]
impl ToolHandler for MyToolHandler {
    async fn validate(&self, config: &serde_json::Value) -> Result<(), ToolError> {
        // éªŒè¯é…ç½®
        if !config.get("required_field").is_some() {
            return Err(ToolError::ValidationFailed("Missing required_field".to_string()));
        }
        Ok(())
    }
    
    async fn execute(&self, input: &serde_json::Value) -> Result<serde_json::Value, ToolError> {
        // æ‰§è¡Œå·¥å…·é€»è¾‘
        let result = serde_json::json!({
            "status": "success",
            "data": input
        });
        Ok(result)
    }
    
    async fn cleanup(&self) -> Result<(), ToolError> {
        // æ¸…ç†èµ„æº
        Ok(())
    }
    
    fn tool_type(&self) -> ToolType {
        ToolType::Custom("MyTool".to_string())
    }
    
    fn description(&self) -> &str {
        "A custom tool handler"
    }
}
```

---

## ğŸš€ å‘å¸ƒå’Œç‰ˆæœ¬æ§åˆ¶

### 1. ç‰ˆæœ¬ç­–ç•¥

- **ä¸»ç‰ˆæœ¬å·**: ä¸å…¼å®¹çš„ API å˜æ›´
- **æ¬¡ç‰ˆæœ¬å·**: å‘åå…¼å®¹çš„åŠŸèƒ½æ€§æ–°å¢
- **ä¿®è®¢ç‰ˆæœ¬å·**: å‘åå…¼å®¹çš„é—®é¢˜ä¿®æ­£

### 2. å‘å¸ƒæ£€æŸ¥æ¸…å•

- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] ä»£ç è¦†ç›–ç‡è¾¾æ ‡
- [ ] æ–‡æ¡£æ›´æ–°å®Œæˆ
- [ ] ç¤ºä¾‹ä»£ç éªŒè¯
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] å®‰å…¨æ‰«æé€šè¿‡

### 3. å‘åå…¼å®¹æ€§

- ä¿æŒæ ¸å¿ƒ trait çš„ç¨³å®šæ€§
- æ–°å¢å­—æ®µä½¿ç”¨ Option ç±»å‹
- åºŸå¼ƒåŠŸèƒ½æä¾›è¿ç§»è·¯å¾„
- è¯¦ç»†çš„å˜æ›´æ—¥å¿—

---

End of Document. 